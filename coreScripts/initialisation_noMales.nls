to set-defaults
  
  ;;Meta-model settings
  set debug? FALSE
  set verbose? FALSE
  set profiler? FALSE
  set capture-data? FALSE
  
  ;;ENVIRONMENT
  
  ;;Island creation
  set num-clust 2
  set clust-area 10
  set clust-density 1
  set num-predator-islands 1
  
  ;;Habitat suitability
  set low-lambda 2
  set high-lambda 90
  set prop-suitable 0.5
  set habitat-aggregation 0.2
  set diffusion-prop 0.3
  
  set nhb-rad 4 ;;Assumed knowledge radius of 450 metres
 
  ;;Environmental effects
  set collapse? TRUE
  set collapse-half-way 70
  set collapse-perc 0.3
  set collapse-curve 2
  
  set prospect? TRUE
  set time-to-prospect 3
  
  set update-colour? TRUE
  
  ;;SEABIRDS
    
  ;;Seabird starting populations
  set starting-juveniles 200
  set starting-seabird-pop 1000
  set sex-ratio 0.5
  
  ;;Philopatry and Emigration
  set age-at-first-breeding 6
  set age-first-return 6
  
  set female-philopatry 0.95
  
  set emigration-timer 2
  set emigration-rate 0.8
  set raft-half-way 100
  set emigrant-perc 0.8
  set emig-out-prob 0.4
  set emigration-curve 0.5
  
  set vagrancy 0.01
  
  set prop-returning-breeders 0.95
  
  ;;Mortality effects
  set natural-chick-mortality 0.4
  set juvenile-mortality 0.65
  set adult-mortality 0.05
  set mortality-sd 0.2
  
  set max-age 28
  set old-mortality 0.8
  
  ;;Predation effects
  set chick-predation 0.5
  set adult-predation 0.05
  
  ;;Island selection
  set isl-att-curve "sigmoid"
  
end



to init-patches ;;Creating default patches and patch-sets (all values set at value for the sea)
  set pred-islands no-patches 
  
  ask patches
  [
    set habitable? FALSE
    set suitable? false 
    set colony-id 0
    set habitat-attrac 0
    set occupancy 0
    set occupancy-limit 0
    set predators? false
    set pcolor blue
    set neighbourhood no-patches
  ]
  
end

;to init-isl-from-file [ datafile-name ]
;  
;  ;;carefully - wrap this function to fail gracefully if there is no file that can be loaded.
;  let init-data csv:from-file  datafile-name
;
;  ;;make the islands as blobs
;  
;  let headers item 0 init-data
;  
;  
;  
;  ;;Something to execute once per row (to create islands) - tie in other function for island creation
;   foreach init-data [ i ->
;   let isl-id item 0 i
;    
;   ;;grow-islands
;    ;;give the it the list i
;    ;;set the patches own
;    
;    ask patches with [isl-id = isl-id]
;    [
;      let cmd word "set"  item 
;      run cmd  
;    ]
;    
;
;    
;  ]
;
;;;Repeats once for each column -define island parameters (all of these to become island-own
;  
;end

to grow-islands ;;Creating islands and colonies
  
  let idx 1 ;;initialising the round counter for definign the habitat-id variable
  
  repeat num-clust
  [
    ask one-of patches with [ count patches with [ pcolor = green ] in-radius (clust-area + 1)  = 0 and abs(pycor) > clust-area and abs(pxcor) > clust-area] ;Bouncing off edge of world
    [
      let cluster patches in-radius clust-area ;of patch-here;creating patch-set of the cluster
      
      set pcolor green
      set habitable? TRUE ;setting this to be desireable habitat for the turtle
      set colony-id idx ;setting habitat-id to a unique value
      
      ask n-of (count(cluster) * clust-density) cluster ;expanding the patch as a function of density and user defined area
      [
        set pcolor green
        set habitable? TRUE ;see above for this line and the one below
        set colony-id idx
      ]
    ]
    set idx (idx + 1) ;updating idx iteration to keep habitat-id names unique
  ]
  
  ;Setting some conviences names
  set colonies patches with [ colony-id > 0 ] ;the baseline initialisation for cells is 0 (i.e. sea cells are 0)
  set the-islands patches with [ habitable? ] ;convenience name
  set island-id sort remove-duplicates [ colony-id ] of the-islands ;;creating a list of island-id's
  set the-sea patches with [ not habitable? ]
 
  ;Creating my predator islands
  let pred-isle-id n-of num-predator-islands n-values num-clust [ i -> i + 1 ] 
  ask patches with [ member? colony-id pred-isle-id ] [ set predators? true ]
  
  ;Convienence names
  set pred-islands patches with [ predators? ]
  set safe-islands patches with [ habitable? = true and not predators? ]
  
  
  ;Creating habitat heterogeneity and storing the colony patch-sets in a list (colonies)
  set colonies []
  foreach island-id [n -> 
    dig-burrows n
    set colonies lput (patches with [colony-id = n]) colonies
  ] 
  
  ;Now diffuse surface
  diffuse occupancy-limit diffusion-prop
  
  ask patches
  [
    set occupancy-limit floor occupancy-limit
  ]
  
  ;Removing occupancy limits that shouldn't exist
  ask the-sea 
  [
    set occupancy-limit 0
  ]

  
  ask patches with [ habitable? ]
  [
    ifelse nhb-rad <= 1 [set neighbourhood (neighbors with [ habitable? ])][set neighbourhood patches with [ habitable? ] in-radius nhb-rad] ; set neighbourhoods for only island patches
  ]
  
  ;;for the colour scale...
  let min-occ-lim min [ occupancy-limit ] of the-islands
  let max-occ-lim max [ occupancy-limit ] of the-islands
  
  ask the-islands
  [  
    ;;making it prettier
    set pcolor scale-color green occupancy-limit max-occ-lim min-occ-lim
    
    ;;initialising habitat attractiveness
    set maxK max [ occupancy-limit ] of neighbourhood
    ask the-islands with [ maxK != 0 ] ;defensive in case there are any patches surrounded by 0
    [
      set habitat-attrac ( occupancy-limit / maxK ) * 0.3
    ]
  ]
  
end

to dig-burrows [ n ]
  
  let island-patches patches with [ colony-id = n ] ;looking at only this island
  let island-size count island-patches ;counting island size for determining suitability
  
  ;; seeds the grid with one patch as suitable
  ask one-of island-patches [ set suitable? true]
  let filled 1
  
  ;; this sequentially fills the grid by selecting patches and making them suitable
  while [filled <= (prop-suitable * island-size)]
  [
    ;; if rnd test is less than attract-suitable then an *unsuitable* patch next to a suitable patch is made suitable
    ifelse random-float 1 <= habitat-aggregation
    [
      ask one-of [ neighbors with [ habitable? ] ] of (island-patches with [suitable?])
      [
        if suitable? = false
        [
          set suitable? true
          set filled filled + 1
        ]
      ]
    ]
    
    ;; otherwise pick a patch at random (this could any neighbouring a suitable patch)
    ;; if you want to make sure it does not you'd need to use
    ;; ask one-of patches with [(not suitable?) and (count neighbors with [suitable?] = 0)]
    [
      ask one-of island-patches with [habitable? and not suitable?]
      ;;ask one-of patches with [(not suitable?) and (count neighbors with [suitable?] = 0)]
      [
        set suitable? true
        set filled filled + 1
      ]
    ]
 ]
  
  ;Now set two different poisson distributions
  ask island-patches 
  [
    ifelse suitable? 
    [
      set occupancy-limit random-poisson high-lambda
    ]
    [
      set occupancy-limit random-poisson low-lambda
    ]
  ]
  
  
  set island-attractiveness [] ; initialising
  
  foreach island-id [ i ->   
    let isl-att round( (1 / max island-id) * 100 )
    set island-attractiveness lput isl-att island-attractiveness
  ]
    
end

to init-adults
  
  ;initialising females
  create-turtles starting-seabird-pop 
  
  ;initialising basic parameters of birds
  ask females
  [
    set shape "bird side"
    setxy 0 0 ;making them all start on the left edge of the ma
    set age age-at-first-breeding + random-poisson 2 ;adding some age variability
    set size 1
    set life-stage "Adult"
    set time-since-breed 0
    
    set settled? false ;Has not been assigned a colony
    set breeding? false ;Has not found a patch
    set mating? false ;Has not found a mate
    
    set breeding-ground-id 0
    set breeding-grounds no-patches
    set burrow no-patches    
  ]
  
  ask females
  [
    set color orange
  ]
  
  set breeders females with [ life-stage = "Adult"]
  
end

to assign-colonies
  
  if debug? [ show island-id ]
  
  ask breeders with [not settled?]
  [
    ;set breeding-ground-id to match a colony-id and that the occupancy is less than the occupancy-limit
    let target-grd one-of island-id
    set breeding-ground-id target-grd
    set natal-ground-id target-grd ;intialising as the breeding-grounds = natal grounds
    set settled? true
    set breeding-grounds patch-set patches with [ colony-id = target-grd ]
    ; if [debug?] [ show "target grd id: " show target-grd ]  
  ]
  
end


to assign-burrows
  
  ask breeders with [ life-stage = "Adult" and breeding-grounds != no-patches ]
  [
    set burrow one-of breeding-grounds with [ occupancy < occupancy-limit ]
    if debug? [ show burrow ] 
  ]
  
end

to init-juveniles

  create-females starting-juveniles
  [

    raise-chick orange
  ]
  
  set recruits turtles with [ life-stage = "Juvenile"]
  
end


to raise-chick [ colour ]
  
  set color colour
  
  set size 1
  set shape "bird side"
  set age random age-at-first-breeding
  set settled? false
  set breeding? false
  set mating? false
  set last-breeding-success? false
  set life-stage "Juvenile"
  set natal-ground-id colony-id
  set breeding-ground-id 0
  set breeding-grounds no-patches
  set burrow no-patches
  set time-since-breed 0
  
end


to assign-natal-grounds
  ask recruits
  [ 
    set natal-ground-id one-of island-id ;Assigning a random colony as natal grounds
  ]
end

to create-data-sheet

  set demography-series ["recruits" "" ] 
  
end



