to recruit
  
  set new-recruits turtles with [ life-stage = "Juvenile" and age = 0]
  let unfortunate-recruits random-binomial count(new-recruits) juvenile-mortality
  
  ;;capturing data
  if capture-data?
  [
    set demography-year lput count(new-recruits) demography-year
    set demography-year lput unfortunate-recruits demography-year
  ]
  
  ask n-of unfortunate-recruits new-recruits
  [
    die
  ]
  
  ask turtles
  [
    set age (age + 1)
  ]
  
  ask turtles with [ life-stage = "Juvenile" ]
  [
    if age >= age-at-first-breeding ;add some variability to this???
    [
      set life-stage "Adult"
    ]
  ]
  
  set breeders turtles with [ life-stage = "Adult" ]
  
end


to philopatry-check
   
  let female-recruits females with [ settled? = false and life-stage = "Adult" ]
  if verbose? [ type "New female recruits:" show count(female-recruits) ]
  choose-colony female-recruits female-philopatry

  ;;capturing data
  if capture-data?
  [
    set demography-year lput count(female-recruits) demography-year  ;; To be updated to divided this by year
  ]
end

;; COLONY CHOICE TO BE OVERHAULED - choice weighting by island attractiveness and potentially have a new group for immigrants who are unable to breed in x consecutive years
to choose-colony [ birds philopatry ] ;;an agentset of birds who need to choose a colony and the philopatry for that sex
  
  ;;Setting the count of birds who failed their philopatry check to zero
  let num-failed 0
  
  ;;philopatry-out keeps count of the number of birds leaving the system on the basis of philopatry each year
  set philopatry-out 0
  
  set emigrators nobody
  
  ;;Checking philopatry by island
  foreach island-id [ n -> 
    
    ;;Subsetting the birds we want to check for
    let isl-birds birds with [ natal-ground-id = n ] 
    
    ;;Checking if there are any to allocate...
    if any? isl-birds
    [
      ;;How many return?
      let num-success random-binomial count(isl-birds) philopatry
      
      ;;Updating their details
      ask n-of num-success isl-birds 
      [ 
        set breeding-grounds item ( natal-ground-id  - 1) colonies  
        set settled? true
        set breeding-ground-id natal-ground-id
      ]
      
      ;;How many birds to allocate
      set num-failed num-failed + (count(isl-birds) - num-success)
      
      ;;A turtle-set of all possible emigrating birds
      set emigrators (turtle-set emigrators isl-birds with [ not settled? ])
      
    ]
  ]
    
  if verbose?
  [
    print (word "Starting emigrators: " emigrators)
    print (word "Failed Philopatry Count: " num-failed)  
  ]
  
  ;;Checking there are some birds to allocate
  if num-failed > 0 
      [
        ;;Allocating on basis of island attractiveness (+ chance of leaving system)
        let isl-allocations multinomial-int num-failed island-attractiveness true
        
        if verbose?
        [
          print (word "Island Allocations: " isl-allocations)   
        ]
        
        ;;Finding the number of possible options to separate those going to islands in the system and those leaving
        let num-opt n-values length isl-allocations [ i -> i ]
        
        ;;Running through each island to allocate the correct number of birds - they can end up at natal island as it is assumed they checked out the others before deciding they had it best.
        ;;THE ABOVE ASSUMPTION MAY CAUSE ISSUES, AS IT WILL LEAD TO A POSTIVE FEEDBACK LOOP, MEANING THE BIRDS ONLY ESCAPE IS EMIGRATION OUTWARD IN SCENARIOS WHERE HIGH DENSITIES ARE FAVOURED....
        foreach num-opt [ o ->
          ifelse o <= max(island-id) - 1 ;;If it is a true island...
          [
            ask n-of item o isl-allocations emigrators with [ not settled? ]
            [
              set breeding-grounds item (o) colonies ;;Plus one because the list is indexed at zero
              set settled? true
              set breeding-ground-id (o + 1)
            ]
          ]
          ;;...or if the count is for emigrating out of the system
          [
            ;;updating the number leaving
            set philopatry-out item o isl-allocations
            
            ;;Checking if any birds are leaving the system
            if philopatry-out > 0 
            [
              ;;birds leaving the system
              ask n-of item o isl-allocations emigrators with [ not settled? ] ;;Assumes that the remaining emigrators were all going to be ejected from the system.
              [
                die          
              ]
            ]
          ]
        ]
        
        if verbose?
        [
          print (word "Remaining emigrators: " emigrators)   
        ]
        
  ]
  
    
;  ask birds
;  [
;    ;; let target-isl multinomial-int 1 isl-attract true ;; how to convert this into a an island choice - outputs [ 1 0 ] for two islands 
;    ifelse random-float 1 < female-philopatry
;    [
;      set breeding-grounds item ( natal-ground-id  - 1) colonies  
;      set settled? true
;      set breeding-ground-id natal-ground-id
;    ]
;    [
;      ;;;;;CODE TO BE OVERHAULED TO ALLOW FOR ISLAND CHOICE
;      let colony-potentials remove natal-ground-id island-id
;      let colony-target one-of colony-potentials
;      set breeding-grounds item (colony-target - 1) colonies  
;      set settled? true
;      set breeding-ground-id one-of [ colony-id ] of breeding-grounds 
;    ]
;  ]
  
end

to emigrate ;Currently kills off birds once they have reached the threshold for number of unsuccessful breeding attempts.
  ;;which birds and how many
  let pot-emigrants breeders with [ time-since-breed >= emigration-timer ]
  let n-pot-emigrants count pot-emigrants
 
  let raft-prob random-sigmoid n-pot-emigrants emigration-curve raft-half-way ;;setting c1 as 2 as this creates a steeper curve with more of threshold
  
  if raft-prob >= random-float 1
  [
    let n-emigrants random-binomial n-pot-emigrants emigrant-perc
    
    ;;capturing data
    if capture-data?
    [
      island-emigrant-census n-emigrants ;;capturing number of emmigrants coming from each island.
    ]
    
    ;;output?
    if verbose? [ type "Number of emigrants" show n-emigrants ]
    
    ask n-of n-emigrants pot-emigrants
    [
      die
    ]
  ]
  
end  

;;MALES ASSIGNED TO PATCHES
to burrowing ;;a task solely for males  
  
  let potential-breeders females with [ settled? and not breeding? and life-stage = "Adult" ]
  ;;potential-breeders returning
  let returning-breeders n-of (random-binomial count(potential-breeders) prop-returning-breeders) potential-breeders ;actual returning individuals
 
  ;;calculating the number of males to distribute across patches
  let num-breeders count(returning-breeders) ;* sex-ratio
  
  foreach island-id [ n ->
    
    ;;Calculating number of males to spread around
    let num-female-breeders count females with [ settled? and life-stage = "Adult" and breeding-ground-id = n ]
    let num-males-to-allocate (num-female-breeders * sex-ratio) ;working out the proportion of males to females : change this to a scalar
    
    ;; pulling the current colony patch-set
    let curr-island item (n - 1) colonies
 
    ;; make a list of patches sorted on attractiveness
    let sorted-att sort-on [ habitat-attrac ] curr-island
    
    ;;Values for the multinomial draw
    let att-only [] ; list to contain habitat attract values
    foreach sorted-att [ sa ->
      set att-only lput round([habitat-attrac] of sa * 100) att-only
    ]
    
    ;; get rounded attractiveness frpm taht sorted list
    let males-to-allocate multinomial-int num-males-to-allocate att-only true
    
    ;; allocate to the patches using another foreach to iterate over sorted patch list
    (foreach sorted-att males-to-allocate [ [a m] ->
      ask a [set male-count m] 
    ])
  ]    
  
  ;;creating a list of patches with males for efficiency when females arrive
  set calling-males []
 
  foreach island-id [i -> 
    let target-colony item (i - 1) colonies
    set calling-males lput (target-colony with [ male-count > 0 ]) calling-males
  ] 
  
end

;; FEMALES FINDING A MATE
to find-mate ;a task solely for females
  
  
  let adult-females females with [ life-stage = "Adult" ]
  
  ;Old pairings
  
  if debug? [type "Mated females " show count(adult-females with [ burrow != no-patches ])]
  
  set old-pairs 0
  
  ask adult-females with [ not breeding? and  burrow != no-patches ] ;females who already have a mate 
  [
    if debug? [ show "Mated female moving" ]
    reunite ;Finding mate from a previous pairing
  ] 
  
  
  ;  ;New pairs
  if debug? [type "Unmated females " show count(adult-females with [ burrow = no-patches ])]
  
  set new-pairs 0 ;counter for new mates
  
  ask adult-females with [ not breeding? and burrow = no-patches ] ;females who need to find a mate
  [
    if debug? [ show "Unmated female moving" ] ;isolating individuals
    pair
  ]
  
  
  if verbose? 
  [
    type "New pairs " show new-pairs ;showing how many newly formed pairs are mating
  ]
  
end

to reunite
  
  move-to burrow ;move straight to their mate
  
  ifelse male-count > 0 and occupancy < occupancy-limit
  [
    nest
  ]
  [
    set burrow no-patches
  ]
  
end

to pair
  
  ;;selecting the patch-set of interest to identify potential burrows
  let target-colony [ breeding-ground-id ] of self
  let potential-burrows item (target-colony - 1) calling-males ;;-1 because lists start at 0
  
  ;;debugging
  if debug? [ type "potential-burrows " show count(potential-burrows) ]
  
  ;;Females hunting for potential home
  if any? potential-burrows
  [
    let tries 1 
    while [ tries < max-tries ]
    [
      
      ifelse tries = 1
      [ 
        move-to one-of potential-burrows
      ]
      [
        let alternatives neighbourhood with [ male-count > 0 and habitat-attrac >= [ habitat-attrac ] of self ] ;;neighbourhood defined at set up and has a radius defined by slider
        ifelse count(alternatives) > 0 ;;Checking there is a neighbour that meets this definition
        [ 
          move-to one-of alternatives ;;move to potential breeding ground
        ]
        [
          move-to one-of potential-burrows with [ habitat-attrac >= [ habitat-attrac ] of self ] ;;will move to somewhere more attractive
        ]
      ]   
      
      ifelse random-float 1 < habitat-attrac ;;checking if the male was successful in courting
      [ 
        nest
        
        set new-pairs new-pairs + 1 ;;counter for number of newly formed pairs    
        set tries (tries + max-tries) ;;end the mate hunt
      ]
      [
        set tries (tries + 1) ;;updating the number of attempts if they didn't find a mate they liked
      ]
    ]
  ]

end

to nest
  ;;updating parameters if courting was successful
  set breeding? true
  set mating? true
  set burrow patch-here
  set occupancy occupancy + 1
  set male-count male-count - 1
  set habitat-attrac (patch-occ * 0.35) + (hab-quality * 0.3) + (local-occ * 0.35)
  
  if male-count = 0 ;;checking if the patch can support anymore females
  [
    no-vacancy ;;removing this patch from the potentials - we assume that the females are only trying where there is a male actively calling for a mate
  ]
end

to no-vacancy ;;updates a patch-set to remove now full patches
  let target-colony ([ breeding-ground-id ] of self) - 1 ;;which patch-set is needed
  let male-group item target-colony calling-males ;;pulling out that patch-set
  set male-group male-group with [ male-count > 0 ] ;;updating the patch-set
  set calling-males replace-item target-colony calling-males male-group  ;;replacing it in the global patch-set
end

;;HATCHING-FLEDGING

to hatching-fledging ;need to ask one in each pair to hatch....
  
  let safe-breeders females with [ mating? and breeding? and not predators? ] ; taking the females on the safe islands...
  reproduce safe-breeders false
  
  let unsafe-breeders females with [ mating? and breeding? and predators? ] ; taking the females on the predator infested islands...
  reproduce unsafe-breeders true
  
end

to reproduce [ breeding-birds predation? ]
  
  ifelse predation?
  [
    foreach island-id [ i ->
      
      let example one-of patches with [ colony-id = i ] 
      let chick-pred [ chick-predation ] of example
      
      let isl-breeding-birds breeding-birds with [ colony-id = i ]
      
      let total-mortality chick-pred + natural-chick-mortality
      let n-breed (binomial count(isl-breeding-birds) (1 - total-mortality))  * random-normal 1 mortality-sd ;Factoring mortality, predation and noise into the hatch success
      set n-breed round(min(list n-breed count(isl-breeding-birds))) ;preventing cases where more are selected than exist    
      let successful-breeders n-of n-breed isl-breeding-birds
      
      if verbose? [ type "Chicks fledged under predation:" show n-breed ] 
      
      ask successful-breeders
      [
        set time-since-breed 0
        hatch-females 1
        [
          raise-chick orange
        ]
      ]
    ]
  ]
  [
    let n-breed (binomial count(breeding-birds) (1 - natural-chick-mortality))  * random-normal 1 mortality-sd ;Factoring mortality, predation and noise into the hatch success    
    set n-breed round(min(list n-breed count(breeding-birds))) ;preventing cases where more are selected than exist
    let successful-breeders n-of n-breed breeding-birds
      
    if verbose? [ type "Chicks fledged without predation:" show n-breed ]
    
    ask successful-breeders
    [
      set time-since-breed 0
      hatch-females 1
      [
        raise-chick orange
      ]
    ]
  ]      

end


to mortality
  
  ;Adult natural mortality
  let adults turtles with [ life-stage = "Adult" and not predators? ]
  let num-adults count adults
  
  let num-fatalities ( binomial num-adults adult-mortality )  * random-normal 1 mortality-sd
  set num-fatalities round(min(list num-fatalities num-adults)) 
  let adult-fatalities n-of num-fatalities adults
  
  ask adult-fatalities ;adult mortality
  [
    die
  ]
  
  ;Adult predation deaths
  foreach island-id [ i ->
    
    ;;Island specific predation
    let example one-of patches with [ colony-id = i ] 
    let adult-pred [ chick-predation ] of example
    
    ;;How many birds are at risk
    let adults-at-risk turtles with [ life-stage = "Adult" and predators? and colony-id = i] 
    let adult-risk-count count adults-at-risk
    
    let num-killed (binomial adult-risk-count (adult-mortality + adult-pred))  * random-normal 1 mortality-sd
    set num-killed round(min(list num-killed adult-risk-count)) 
    let adult-killed n-of num-killed adults-at-risk
    
    ask adult-killed;adult predation
    [
      die
    ]
  ]
  
  ;senescence of old birds
  let seniors turtles with [age > max-age]
  ask n-of ( random-binomial count(seniors) old-mortality ) seniors
  [
    die 
  ]
  
end

to census
  
  ;;Storing data!! To come
  isl-adult-n 
  ;set island-series lput adult-isl-counts island-series
 
end

;Moving birds off islands, resetting breeding and mating, then clearing burrow current occupancy 
to season-reset

  assess-islands ;;updating the attractiveness of islands for the philopatry test
  
  ;updating counter as these birds may move on in future seasons
  ask breeders
  [
    set time-since-breed time-since-breed + 1 ;;birds which have just bred will have a value of 1
  ]
  
   ;;creation of new burrows
  if prospect? 
  [
    prospect
  ]
  
  ;;chance of burrows collapsing
  if collapse?
  [
    collapse 
  ]
  
  ;;Updating habitat attractiveness values
  if collapse? or prospect?
  [
    update-attract
  ]
  
   ;; purely for nice visualisations.... probably stupidly expensive
  if update-colour?
  [
    
    ;;for the colour scale...
    let min-occ-lim min [ occupancy-limit ] of the-islands
    let max-occ-lim max [ occupancy-limit ] of the-islands
    
    ask the-islands
    [  
      set pcolor scale-color green occupancy-limit max-occ-lim min-occ-lim
    ]
  ]
  
  ;Resetting
  ask turtles
  [
    setxy 0 0
    set breeding? false
    set mating? false
  ]
  
  ask the-islands
  [
    set occupancy 0
    set male-count 0
  ]
  
end

to assess-islands
  
  ;Clearing the list
  set isl-occ[]
  
  ;Updating island occupancies
  foreach island-id [ n ->
    
    let target-isl the-islands with [ colony-id = n ]
    set isl-occ lput sum [ occupancy ] of target-isl isl-occ
    
  ]
 
  ;; Calculating the occupancy of all the islands
  set world-occ sum(isl-occ)
  
  ;;Emptying attractiveness list for recalculation
  set island-attractiveness []
  
  ;;Calculating island attractiveness based on curves
    if isl-att-curve = "uniform"
  [ 
    foreach island-id [ n ->
      let isl-att 1 / max(island-id)
      set island-attractiveness lput isl-att island-attractiveness
    ]
  ]
  
  if isl-att-curve = "linear"
  [
    show "linear"
     foreach island-id [ n ->
      let isl-att item (n - 1) isl-occ / world-occ
      set island-attractiveness lput isl-att island-attractiveness
    ]
  ]
  
  if isl-att-curve = "sigmoid"
  [
    foreach island-id [ n ->
      let occ-prop item (n - 1) isl-occ / world-occ
      let isl-att random-sigmoid occ-prop  0.5 1
      set island-attractiveness lput isl-att island-attractiveness
    ]
  ]
  
    if isl-att-curve = "asymptotic"
  [
    foreach island-id [ n ->
      let occ-prop item (n - 1) isl-occ / world-occ
      let isl-att asymptotic-pdf occ-prop 1 asymp-curve       
      set island-attractiveness lput isl-att island-attractiveness  
    ]
  ]
  
  if isl-att-curve = "beta1"
  [
    show "beta1"
    foreach island-id [ n ->
      let occ-prop item (n - 1) isl-occ / world-occ
      show occ-prop
      let isl-att dbeta occ-prop 2 2
      set island-attractiveness lput isl-att island-attractiveness  
    ]
    set island-attractiveness map [ ia -> ia + 0.01 ] island-attractiveness
    show island-attractiveness
    let beta-sum sum island-attractiveness
    show beta-sum
    set island-attractiveness map [ ia -> ia / beta-sum ] island-attractiveness
    show island-attractiveness
    
  ]
  
  if isl-att-curve = "beta2"
  [
    foreach island-id [ n ->
      let occ-prop item (n - 1) isl-occ / world-occ
      let isl-att dbeta occ-prop 5 1
      set island-attractiveness lput isl-att island-attractiveness  
    ]
    let beta-sum sum island-attractiveness
    set island-attractiveness map [ bs -> bs / beta-sum ] island-attractiveness
  ]
  
  ;;Adding on probability of emigrating out of the system
  set island-attractiveness lput emig-out-prob island-attractiveness
  
  ;;Calculating the total to divide by
  let total-att sum(island-attractiveness)
  
  ;;Normalising to be between 0 and 100
  set island-attractiveness map [ ta -> round((ta / total-att) * 100) ] island-attractiveness


end


to island-emigrant-census [emigrants]
  
  foreach island-id [ n ->
  set island-year lput count(emigrants) island-year ;; To be updated to divided this by year
  ]
  
end

to prospect
  
  ;;digging out new burrows
  ask the-islands with [ male-count > 0 ]
  [
    let new-burrows round ( male-count / time-to-prospect )
    set occupancy-limit occupancy-limit + new-burrows
  ]
  
end

to collapse
  
  foreach island-id [ i ->
    
    let example one-of patches with [ colony-id = i ] 
    let middle-collapse [ collapse-half-way ] of example
    let extent-collapse [ collapse-perc ] of example
    ;;checking to see if patches collapes
    ask the-islands with [ colony-id = i]
    [
      
      ;;sigmoid distribution
      ;;2 is the c1 value controlling curve. This creates a steeper curve to show more a threshold
      let collapse-prob random-sigmoid occupancy-limit 2 middle-collapse
      
      ;;debugging
      if debug? [ show collapse-prob ]
      
      if collapse-prob >= random-float 1
      [
        let n-collapse random-binomial occupancy-limit extent-collapse
        
        ;;output? - this will be very lengthy....
        if verbose? [ type "Burrows lost" show n-collapse ]
        
        set occupancy-limit occupancy-limit - n-collapse
      ]
    ]
  ]
  
end

to update-attract
  ask the-islands
  [
    ;;initialising habitat attractiveness
    set maxK max [ occupancy-limit ] of neighbourhood
    ask the-islands with [ maxK != 0 ] ;defensive in case there are any patches surrounded by 0
    [
      set habitat-attrac ( occupancy-limit / maxK ) * 0.3
    ]
  ]
end


